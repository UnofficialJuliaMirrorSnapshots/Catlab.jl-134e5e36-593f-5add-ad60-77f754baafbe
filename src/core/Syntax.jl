""" Syntax for a generalized algebraic theory (GAT).

Unlike instances of a theory, syntactic expressions don't necessarily satisfy
the equations of the theory. For example, the default syntax operations for the
`Category` theory don't form a category because they don't satisfy the category
laws, e.g.,
```
compose(f, id(A)) != compose(f)
```
Whether dependent types are enforced at runtime and whether expressions are
automatically brought to normal form depends on the particular syntax. In
general, a single theory may have many different syntaxes. The purpose of this
module to make the construction of syntax simple but flexible.
"""
module Syntax
export @syntax, GATExpr, SyntaxDomainError, head, args, type_args, first, last,
  invoke_term, functor, to_json_sexpr, parse_json_sexpr, show_sexpr,
  show_unicode, show_latex

import Base: first, last
import Base.Meta: ParseError, show_sexpr
using Match

using ..GAT: Context, Signature, TypeConstructor, TermConstructor, Typeclass
import ..GAT
import ..GAT: invoke_term
using ..Meta

# Data types
############

""" Base type for expression in the syntax of a GAT.

We define Julia types for each *type constructor* in the theory, e.g., object,
morphism, and 2-morphism in the theory of 2-categories. Of course, Julia's
type system does not support dependent types, so the type parameters are
incorporated in the Julia types. (They are stored as extra data in the
expression instances.)
  
The concrete types are structurally similar to the core type `Expr` in Julia.
However, the *term constructor* is represented as a type parameter, rather than
as a `head` field. This makes dispatch using Julia's type system more
convenient.
"""
abstract type GATExpr{T} end

head(::GATExpr{T}) where T = T
args(expr::GATExpr) = expr.args
first(expr::GATExpr) = first(args(expr))
last(expr::GATExpr) = last(args(expr))
type_args(expr::GATExpr) = expr.type_args

function Base.:(==)(e1::GATExpr, e2::GATExpr)
  head(e1) == head(e2) && args(e1) == args(e2) && type_args(e1) == type_args(e2)
end
function Base.hash(e::GATExpr, h::UInt)
  hash(args(e), hash(head(e), h))
end

function Base.show(io::IO, expr::GATExpr)
  print(io, head(expr))
  print(io, "(")
  join(io, args(expr), ",")
  print(io, ")")
end
function Base.show(io::IO, expr::GATExpr{:generator})
  print(io, first(expr))
end

struct SyntaxDomainError <: Exception
  constructor::Symbol
  args::Vector
end

function Base.showerror(io::IO, exc::SyntaxDomainError)
  print(io, "Domain error in term constructor $(exc.constructor)(")
  join(io, exc.args, ",")
  print(io, ")")
end

# Syntax
########

""" Define a *syntax* system for a generalized algebraic theory (GAT).

A syntax system consists of Julia types (with top type `GATExpr`) for each type
constructor in the signature, plus Julia functions for

1. *Generators*: creating new generator terms, e.g., objects or morphisms
2. *Accessors*: accessing type parameters, e.g., domains and codomains
3. *Term constructors*: applying term constructors, e.g., composition and
   monoidal products

Julia code for all this is generated by the macro. Any of the methods can be
overriden with custom simplification logic.
"""
macro syntax(syntax_head, mod_name, body=Expr(:block))
  @assert body.head == :block
  syntax_name, base_types = @match syntax_head begin
    Expr(:call, [name::Symbol, args...]) => (name, args)
    name::Symbol => (name, [])
    _ => throw(ParseError("Ill-formed syntax signature $syntax_head"))
  end
  functions = map(parse_function, strip_lines(body).args)
  
  expr = Expr(:call, :syntax_code, Expr(:quote, syntax_name),
              esc(Expr(:ref, :Type, base_types...)),
              esc(mod_name), esc(nameof(__module__)), functions)
  Expr(:block,
    Expr(:call, esc(:eval), expr),
    :(Core.@__doc__ $(esc(syntax_name))))
end
function syntax_code(name::Symbol, base_types::Vector{Type},
                     signature_module::Module, outer_module::Module,
                     functions::Vector)
  class = signature_module.class()
  signature = class.signature
  signature_ref = GlobalRef(parentmodule(signature_module),
                            nameof(signature_module))
  
  # Generate module with syntax types and type/term generators.
  mod = Expr(:module, true, name,
    Expr(:block, [
      # Prevents error about export not being at toplevel.
      # https://github.com/JuliaLang/julia/issues/28991
      LineNumberNode(0);
      Expr(:export, [cons.name for cons in signature.types]...);
      Expr(:using, map(Symbol, split(string(outer_module), "."))...);
      :(signature() = $signature_ref);
      gen_types(signature, base_types);
      gen_type_accessors(signature);
      gen_term_generators(signature, outer_module);
      gen_term_constructors(signature, outer_module);
    ]...))
  
  # Generate toplevel functions.
  toplevel = []
  bindings = Dict{Symbol,Any}(
    c.name => Expr(:(.), name, QuoteNode(c.name)) for c in signature.types)
  bindings[:Super] = name
  syntax_fns = Dict(parse_function_sig(f) => f for f in functions)
  for f in interface(class)
    sig = parse_function_sig(f)
    if haskey(syntax_fns, sig)
      # Case 1: The method is overriden in the syntax body.
      expr = generate_function(replace_symbols(bindings, syntax_fns[sig]))
    elseif !isnothing(f.impl)
      # Case 2: The method has a default implementation in the signature.
      expr = generate_function(replace_symbols(bindings, f))
    else
      # Case 3: Call the default syntax method.
      params = [ gensym("x$i") for i in eachindex(sig.types) ]
      call_expr = Expr(:call, sig.name, 
        [ Expr(:(::), p, t) for (p,t) in zip(params, sig.types) ]...)
      body = Expr(:call, Expr(:(.), name, QuoteNode(sig.name)), params...)
      f_impl = JuliaFunction(call_expr, f.return_type, body)
      expr = generate_function(replace_symbols(bindings, f_impl))
    end
    push!(toplevel, expr)
  end
  Expr(:toplevel, mod, toplevel...)
end

""" Complete set of Julia functions for a syntax system.
"""
function interface(class::Typeclass)::Vector{JuliaFunction}
  sig = class.signature
  [ GAT.interface(class);
    [ GAT.constructor(constructor_for_generator(cons), sig)
      for cons in sig.types ]; ]
end

""" Generate syntax type definitions.
"""
function gen_type(cons::TypeConstructor, base_type::Type=Any)::Expr
  base_expr = GlobalRef(Syntax, :GATExpr)
  base_name = if base_type == Any
    base_expr
  else
    GlobalRef(parentmodule(base_type), nameof(base_type))
  end
  expr = :(struct $(cons.name){T} <: $base_name{T}
    args::Vector
    type_args::Vector{$base_expr}
  end)
  generate_docstring(strip_lines(expr, recurse=true), cons.doc)
end
function gen_types(sig::Signature, base_types::Vector{Type})::Vector{Expr}
  if isempty(base_types)
    map(gen_type, sig.types)
  else
    map(gen_type, sig.types, base_types)
  end
end

""" Generate accessor methods for type parameters.
"""
function gen_type_accessors(cons::TypeConstructor)::Vector{Expr}
  fns = []
  sym = gensym(:x)
  for (i, param) in enumerate(cons.params)
    call_expr = Expr(:call, param, Expr(:(::), sym, cons.name))
    return_type = GAT.strip_type(cons.context[param])
    body = Expr(:ref, Expr(:(.), sym, QuoteNode(:type_args)), i)
    push!(fns, generate_function(JuliaFunction(call_expr, return_type, body)))
  end
  fns
end
function gen_type_accessors(sig::Signature)::Vector{Expr}
  vcat(map(gen_type_accessors, sig.types)...)
end

""" Generate methods for syntax term constructors.
"""
function gen_term_constructor(cons::TermConstructor, sig::Signature,
                              mod::Module; dispatch_type::Symbol=Symbol())::Expr
  head = GAT.constructor(cons, sig)
  call_expr, return_type = head.call_expr, head.return_type
  if dispatch_type == Symbol()
    dispatch_type = cons.name
  end
  body = Expr(:block)
  
  # Create expression to check constructor domain.
  eqs = GAT.equations(cons, sig)
  if !isempty(eqs)
    clauses = [ Expr(:call,:(==),lhs,rhs) for (lhs,rhs) in eqs ]
    conj = foldr((x,y) -> Expr(:(&&),x,y), clauses)
    insert!(call_expr.args, 2,
      Expr(:parameters, Expr(:kw, :strict, false)))
    push!(body.args,
      Expr(:if,
        Expr(:(&&), :strict, Expr(:call, :(!), conj)),
        Expr(:call, :throw,
          Expr(:call, GlobalRef(Syntax, :SyntaxDomainError),
            Expr(:quote, cons.name),
            Expr(:vect, cons.params...)))))
  end
  
  # Create call to expression constructor.
  type_params = gen_term_constructor_params(cons, sig, mod)
  push!(body.args,
    Expr(:call,
      Expr(:curly, return_type, Expr(:quote, dispatch_type)),
      Expr(:vect, cons.params...),
      Expr(:vect, type_params...)))
  
  generate_function(JuliaFunction(call_expr, return_type, body))
end
function gen_term_constructors(sig::Signature, mod::Module)::Vector{Expr}
  [ gen_term_constructor(cons, sig, mod) for cons in sig.terms ]
end

""" Generate expressions for type parameters of term constructor.

Besides expanding the implicit variables, we must handle two annoying issues:

1. Add types for method dispatch where necessary (see `GAT.add_type_dispatch`)
   FIXME: We are currently only handling the nullary case (e.g., `munit()`).
   To handle the general case, we need to do basic type inference.

2. Rebind the term constructors to ensure that user overrides are preferred over
   the default term constructors.
"""
function gen_term_constructor_params(cons, sig, mod)::Vector
  expr = GAT.expand_term_type(cons, sig)
  raw_params = @match expr begin
    Expr(:call, [name::Symbol, args...]) => args
    _::Symbol => []
  end
  
  bindings = Dict(c.name => GlobalRef(mod, c.name) for c in sig.terms)
  params = []
  for expr in raw_params
    expr = replace_nullary_constructors(expr, sig)
    expr = replace_symbols(bindings, expr)
    push!(params, expr)
  end
  params
end
function replace_nullary_constructors(expr, sig)
  @match expr begin
    Expr(:call, [name::Symbol]) => begin
      terms = sig.terms[findall(cons -> cons.name == name, sig.terms)]
      @assert length(terms) == 1
      Expr(:call, name, terms[1].typ)
    end
    Expr(:call, [name::Symbol, args...]) =>
      Expr(:call, name, [replace_nullary_constructors(a,sig) for a in args]...)
    _ => expr
  end
end

""" Generate methods for term generators.

Generators are extra term constructors created automatically for the syntax.
"""
function gen_term_generator(cons::TypeConstructor, sig::Signature, mod::Module)::Expr
  gen_term_constructor(constructor_for_generator(cons), sig, mod;
                       dispatch_type = :generator)
end
function gen_term_generators(sig::Signature, mod::Module)::Vector{Expr}
  [ gen_term_generator(cons, sig, mod) for cons in sig.types ]
end
function constructor_for_generator(cons::TypeConstructor)::TermConstructor
  value_param = :__value__
  params = [ value_param; cons.params ]
  typ = Expr(:call, cons.name, cons.params...)
  context = merge(Context(value_param => :Any), cons.context)
  TermConstructor(cons.name, params, typ, context)
end

# Reflection
############

""" Invoke a term constructor by name in a syntax system.

This method provides reflection for syntax systems. In everyday use the generic
method for the constructor should be called directly, not through this function.
"""
function invoke_term(syntax_module::Module, constructor_name::Symbol, args...)
  signature_module = syntax_module.signature()
  signature = signature_module.class().signature
  syntax_types = Tuple(getfield(syntax_module, cons.name) for cons in signature.types)
  invoke_term(signature_module, syntax_types, constructor_name, args...)
end

""" Name of constructor that created expression.
"""
function constructor_name(expr::GATExpr)::Symbol
  if head(expr) == :generator
    nameof(typeof(expr))
  else
    head(expr)
  end
end

""" Create generator of the same type as the given expression.
"""
function generator_like(expr::GATExpr, value)::GATExpr
  invoke_term(
    parentmodule(typeof(expr)),
    nameof(typeof(expr)),
    value,
    type_args(expr)...
  )
end

# Functors
##########

""" Functor from GAT expression to GAT instance.

Strictly speaking, we should call these "structure-preserving functors" or,
better, "model homomorphisms of GATs". But this is a category theory library,
so we'll go with the simpler "functor".

A functor is completely determined by its action on the generators. There are
several ways to specify this mapping:

  1. Simply specify a Julia instance type for each doctrine type, using the
     required `types` tuple. For this to work, the generator constructors
     must be defined for the instance types.

  2. Explicitly map each generator term to an instance value, using the
     `generators` dictionary.
  
  3. For each doctrine type (e.g., object and morphism), specify a function
     mapping generator terms of that type to an instance value, using the
     `terms` dictionary.

The `terms` dictionary can also be used for special handling of non-generator
expressions. One use case for this capability is defining forgetful functors,
which map non-generators to generators.
"""
function functor(types::Tuple, expr::GATExpr;
                 generators::AbstractDict=Dict(), terms::AbstractDict=Dict())
  # Special case: look up a specific generator.
  if head(expr) == :generator && haskey(generators, expr)
    return generators[expr]
  end
  
  # Special case: look up by type of term (usually a generator).
  name = constructor_name(expr)
  if haskey(terms, name)
    return terms[name](expr)
  end
  
  # Otherwise, we need to call a term constructor (possibly for a generator).
  # Recursively evalute the arguments.
  term_args = []
  for arg in args(expr)
    if isa(arg, GATExpr)
      arg = functor(types, arg; generators=generators, terms=terms)
    end
    push!(term_args, arg)
  end
  
  # Invoke the constructor in the codomain category!
  syntax_module = parentmodule(typeof(expr))
  signature_module = syntax_module.signature()
  invoke_term(signature_module, types, name, term_args...)
end

# Serialization
###############

""" Serialize expression as JSON-able S-expression.

The format is an S-expression encoded as JSON, e.g., "compose(f,g)" is
represented as ["compose", f, g].
"""
function to_json_sexpr(expr::GATExpr;
    by_reference::Function = default_to_json_by_reference
  )
  if head(expr) == :generator && by_reference(first(expr))
    to_json_sexpr(first(expr))
  else
    [ string(constructor_name(expr)); map(to_json_sexpr, args(expr)) ]
  end
end
to_json_sexpr(::Nothing) = nothing
to_json_sexpr(x::String) = x
to_json_sexpr(x::Real) = x
to_json_sexpr(x::Bool) = x
to_json_sexpr(x) = string(x)

default_to_json_by_reference(x) = false

""" Deserialize expression from JSON-able S-expression.

If `symbols` is true (the default), strings are converted to symbols.
"""
function parse_json_sexpr(syntax_module::Module, sexpr;
    parse_head::Function = identity,
    parse_reference::Function = disable_parse_json_reference,
    parse_value::Function = identity,
    symbols::Bool = true,
  )
  signature_module = syntax_module.signature()
  signature = signature_module.class().signature
  type_lens = Dict(cons.name => length(cons.params) for cons in signature.types)
  
  # The "value" type is
  # - false if the sexpr should be parsed as a term (GAT expression)
  # - true if the sexpr should be parsed as a value (Julia object)
  function parse_impl(sexpr::Vector, ::Type{Val{false}})
    name = Symbol(parse_head(symbols ? Symbol(sexpr[1]) : sexpr[1]))
    nargs = length(sexpr) - 1
    args = [
      parse_impl(arg, Val{
        (i == 1 && get(type_lens, name, nothing) == nargs-1) ||
        isa(arg, Bool) || isa(arg, Number) || isa(arg, Nothing)
      })
      for (i, arg) in enumerate(sexpr[2:end])
    ]
    invoke_term(syntax_module, name, args...)
  end
  parse_impl(x, ::Type{Val{true}}) = parse_value(x)
  parse_impl(x::String, ::Type{Val{false}}) = parse_reference(symbols ? Symbol(x) : x)
  parse_impl(x::String, ::Type{Val{true}}) = parse_value(symbols ? Symbol(x) : x)
  
  parse_impl(sexpr, Val{false})
end

disable_parse_json_reference(x) = error("Loading terms by name is not enabled")

# Pretty-print
##############

""" Show the syntax expression as an S-expression.

Cf. the standard library function `Meta.show_sexpr`.
"""
show_sexpr(expr::GATExpr) = show_sexpr(stdout, expr)

function show_sexpr(io::IO, expr::GATExpr)
  if head(expr) == :generator
    print(io, repr(first(expr)))
  else
    print(io, "(")
    join(io, [string(head(expr));
              [sprint(show_sexpr, arg) for arg in args(expr)]], " ")
    print(io, ")")
  end
end

""" Show the expression in infix notation using Unicode symbols.
"""
show_unicode(expr::GATExpr) = show_unicode(stdout, expr)
show_unicode(io::IO, x::Any; kw...) = show(io, x)

function show_unicode(io::IO, expr::GATExpr; kw...)
  # By default, show in prefix notation.
  print(io, head(expr))
  print(io, "[")
  join(io, [sprint(show_unicode, arg) for arg in args(expr)], ",")
  print(io, "]")
end

function show_unicode(io::IO, expr::GATExpr{:generator}; kw...)
  print(io, first(expr))
end

function show_unicode_infix(io::IO, expr::GATExpr, op::String;
                            paren::Bool=false)
  show_unicode_paren(io, expr) = show_unicode(io, expr; paren=true)
  if (paren) print(io, "(") end
  join(io, [sprint(show_unicode_paren, arg) for arg in args(expr)], op)
  if (paren) print(io, ")") end
end

""" Show the expression in infix notation using LaTeX math.

Does *not* include `\$` or `\\[begin|end]{equation}` delimiters.
"""
show_latex(expr::GATExpr) = show_latex(stdout, expr)
show_latex(io::IO, sym::Symbol; kw...) = print(io, sym)
show_latex(io::IO, x::Any; kw...) = show(io, x)

function show_latex(io::IO, expr::GATExpr; kw...)
  # By default, show in prefix notation.
  print(io, "\\mathop{\\mathrm{$(head(expr))}}")
  print(io, "\\left[")
  join(io, [sprint(show_latex, arg) for arg in args(expr)], ",")
  print(io, "\\right]")
end

function show_latex(io::IO, expr::GATExpr{:generator}; kw...)
  # Try to be smart about using text or math mode.
  content = string(first(expr))
  if all(isletter, content) && length(content) > 1
    print(io, "\\mathrm{$content}")
  else
    print(io, content)
  end
end

function show_latex_infix(io::IO, expr::GATExpr, op::String;
                          paren::Bool=false, kw...)
  show_latex_paren(io, expr) = show_latex(io, expr; paren=true, kw...)
  sep = op == " " ? op : " $op "
  if (paren) print(io, "\\left(") end
  join(io, [sprint(show_latex_paren, arg) for arg in args(expr)], sep)
  if (paren) print(io, "\\right)") end
end

function show_latex_script(io::IO, expr::GATExpr, head::String;
                           super::Bool=false, kw...)
  print(io, head, super ? "^" : "_", "{")
  join(io, [sprint(show_latex, arg) for arg in args(expr)], ",")
  print(io, "}")
end

end
